# خواندن نوع داده

در فصل [مفاهیم پایه](/core_language.html) به صورت تعاملی با حال و هوای کدنویسی در Elm آشنا شدیم. خوب، دوباره این کار را خواهیم کرد، اما با یک سوال جدید در ذهن. **نوع داده** مقدار خروجی کدام است؟ 

## نوع‌های اولیه و لیست‌ها

بیایید چند عبارت ساده وارد کنیم و ببینیم چه اتفاقی می‌افتد:

```elm
> "hello"
"hello" : String

> not True
False : Bool

> round 3.1415
3 : Int
```

`3.1415` را تایپ کنید و کلید ENTER را فشار دهید. باید `3.1415` را به همراه نوع `Float` چاپ کند.

خوب، اما دقیقا چه اتفاقی در حال وقوع است؟ هر ورودی نشان‌دهنده مقدار به همراه **نوع داده** آن است. می‌توانید این مثال‌ها را به صورت زیر بخوانید:

- مقدار `"hello"` یک `String` است.
- مقدار `False` یک `Bool` است.
- مقدار `3` یک `Int` است.
-مقدار `3.1415` یک `Float` است.

Elm قادر است نوع داده هر مقداری که وارد می‌کنید را تشخیص دهد! بیایید ببینیم با لیست‌ها چه اتفاقی می‌افتد:

```elm
> [ "Alice", "Bob" ]
["Alice","Bob"] : List String

> [ 1.0, 8.6, 42.1 ]
[1.0,8.6,42.1] : List Float
```

می‌توانید این نوع داده را به صورت زیر بخوانید:

1. یک `List` پر از مقادیر `String` داریم.
2. یک `List` پر از مقادیر `Float` داریم.

**نوع داده** یک توصیف کلی از مقدار خاصی است که به آن نگاه می‌کنیم.

## توابع

بیایید نوع داده یک تابع را ببینیم:

```elm
> String.length
<function> : String -> Int
```

سعی کنید تابع `round` یا `sqrt` را وارد کنید تا نوع داده آن را ببینید.

تابع `String.length` نوع داده `String -> Int` دارد. به این معنی است که یک آرگومان `String` می‌گیرد و یک مقدار `Int` برمی‌گرداند. پس بیایید سعی کنیم یک آرگومان به آن بدهیم:

```elm
> String.length "Supercalifragilisticexpialidocious"
34 : Int
```

پس با یک تابع `String -> Int` شروع می‌کنیم و یک آرگومان `String` به آن می‌دهیم. این فراخوانی منجر به یک مقدار `Int` می‌شود.

اما چه اتفاقی می‌افتد اگر یک `String` ندهید؟ سعی کنید `String.length [1,2,3]` یا `String.length True` را وارد کنید تا ببینید چه اتفاقی می‌افتد.

متوجه خواهید شد که یک تابع `String -> Int` *باید* یک آرگومان `String` بگیرد!

> **توجه:** توابعی که چندین آرگومان می‌گیرند، در نهایت دارای پیکان‌های بیشتری می‌شوند. به عنوان مثال، اینجا یک تابع داریم که دو آرگومان می‌گیرد:
>
```elm
> String.repeat
<function> : Int -> String -> String
```

>
> دادن دو آرگومان مانند `String.repeat 3 "ha"` منجر به `"hahaha"` می‌شود. فکر کردن به `->` به عنوان یک روش عجیب برای جدا کردن آرگومان‌ها خوب است، اما دلیل واقعی آن را [اینجا](/appendix/function_types.md) توضیح می‌دهم. این واقعا جالب است!

## نشانه‌گذاری نوع داده

تا به حال فقط اجازه داده‌ایم Elm نوع داده را تشخیص دهد، اما این امکان وجود دارد که یک **نشانه‌گذاری نوع داده** را در خط بالای تعریف تابع بنویسید. هنگام کدنویسی، می‌توانید چیزهایی مانند این بگویید:

```elm
half : Float -> Float
half n =
  n / 2

-- half 256 == 128
-- half "3" -- error!

hypotenuse : Float -> Float -> Float
hypotenuse a b =
  sqrt (a^2 + b^2)

-- hypotenuse 3 4  == 5
-- hypotenuse 5 12 == 13

checkPower : Int -> String
checkPower powerLevel =
  if powerLevel > 9000 then "It's over 9000!!!" else "Meh"

-- checkPower 9001 == "It's over 9000!!!"
-- checkPower True -- error!
```

افزودن نشانه‌گذاری نوع داده الزامی نیست، اما قطعا توصیه می‌شود! مزایای آن شامل:

1. **کیفیت پیام خطا** &mdash; افزودن نشانه‌گذاری نوع داده، به کامپایلر می‌گوید که _در حال تلاش_ برای انجام چه کاری هستید.پیاده‌سازی ممکن است اشتباهاتی داشته باشد و حالا کامپایلر می‌تواند آن را با قصد و نیت شما مقایسه کند. &ldquo;گفتید آرگومان `powerLevel` یک `Int` است، اما به عنوان یک `String` استفاده می‌شود!&rdquo;

2. **مستندات** &mdash; وقتی بعدا به کد مراجعه می‌کنید (یا وقتی یک همکار برای اولین بار به آن مراجعه می‌کند) دیدن اینکه چه چیزی به داخل و خارج از تابع می‌رود، بدون اینکه مجبور باشید پیاده‌سازی را به دقت بخوانید، می‌تواند واقعا مفید باشد.

با این حال، افراد ممکن است در نشانه‌گذاری نوع داده اشتباه کنند، پس اگر نشانه‌گذاری نوع داده با پیاده‌سازی مطابقت نداشته باشد چه اتفاقی می‌افتد؟ کامپایلر تمام نوع داده را به تنهایی تشخیص می‌دهد و بررسی می‌کند که آیا نشانه‌گذاری نوع داده با پاسخ واقعی مطابقت دارد یا خیر. به عبارت دیگر، کامپایلر همیشه تایید می‌کند که تمام نشانه‌گذاری‌های نوع داده که اضافه می‌کنید صحیح هستند. بنابراین شما پیام‌های خطای بهتری دریافت می‌کنید _و_ مستندات همیشه بروز باقی می‌ماند!

## متغیرهای نوع داده

با مرور بیشتر کد Elm، شروع به دیدن نشانه‌گذاری‌های نوع داده با حروف کوچک در آن‌ها خواهید کرد. یک مثال رایج تابع `List.length` است:

```elm
> List.length
<function> : List a -> Int
```

آیا آن `a` کوچک در نوع داده را متوجه شدید؟ به آن **متغیر نوع داده** می‌گویند. این می‌تواند بسته به اینکه چگونه [`List.length`][length] استفاده می‌شود، متفاوت باشد:

```elm
> List.length [1,1,2,3,5,8]
6 : Int

> List.length ["a", "b", "c"]
3 : Int

> List.length [True, False]
2 : Int
```

ما فقط طول لیست را می‌خواهیم، بنابراین مهم نیست که چه چیزی در آن وجود دارد. بنابراین متغیر نوع داده `a` می‌گوید که می‌توانیم هر مقداری را مطابقت دهیم. بیایید به یک مثال رایج دیگر نگاه کنیم:

```elm
> List.reverse
<function> : List a -> List a

> List.reverse ["a", "b", "c"]
["c", "b", "a"] : List String

> List.length [True, False]
[False, True] : List Bool
```

دوباره، متغیر نوع داده `a` می‌تواند بسته به اینکه چگونه [`List.reverse`][reverse] استفاده می‌شود، متفاوت باشد. اما در این مورد، ما یک `a` در ورودی و خروجی داریم. به این معنی که اگر یک `List Int` بدهید، باید یک `List Int` نیز دریافت کنید. هنگامی که تصمیم می‌گیریم `a` چیست، نوع داده آن در جاهای دیگر تکرار می‌شود.

> **توجه:** متغیرهای نوع داده باید با یک حرف کوچک شروع شوند، اما می‌توانند کلمات کامل باشند. می‌توانیم نوع داده`List.length` را به صورت `List value -> Int` و نوع داده `List.reverse` را به صورت `List element -> List element` بنویسیم. این نام‌گذاری خوب است به شرطی که با یک حرف کوچک شروع شود. متغیرهای نوع داده `a` و `b` به طور متداول در بسیاری از جاها استفاده می‌شوند، اما برخی از نشانه‌گذاری‌های نوع داده از نام‌های خاص‌تر بهره‌مند می‌شوند.

[length]: https://package.elm-lang.org/packages/elm/core/latest/List#length  
[reverse]: https://package.elm-lang.org/packages/elm/core/latest/List#reverse

## متغیرهای نوع داده محدود شده

یک نوع خاص از متغیرهای نوع داده در Elm وجود دارد که به آن **متغیر نوع داده محدود شده** می‌گویند. رایج‌ترین مثال نوع داده `number` است که تابع [`negate`](https://package.elm-lang.org/packages/elm/core/latest/Basics#negate) از آن استفاده می‌کند:

```elm
> negate
<function> : number -> number
```

سعی کنید عبارات مانند `negate 3.1415` و `negate (round 3.1415)` و `negate "hi"` را امتحان کنید.

به طور معمول، متغیرهای نوع داده می‌توانند با هر چیزی پر شوند، اما `number` فقط می‌تواند با مقادیر `Int` و `Float` پر شود. این کار _محدودیت‌هایی_ برای حالت‌های ممکن ایجاد می‌کند.

فهرست کامل این متغیرها به شرح زیر است:

- `number` به `Int` و `Float` اجازه می‌دهد
- `appendable` به `String` و `List a` اجازه می‌دهد
- `comparable` به `Int`، `Float`، `Char`، `String` و لیست/تاپل با مقدار `comparable` اجازه می‌دهد
- `compappend` به `String` و `List comparable` اجازه می‌دهد

این متغیرهای نوع داده محدود شده وجود دارند تا عملگرهایی مانند `(+)` و `(<)` انعطاف‌پذیر بیشتری داشته باشند.

تا اینجا، پوشش خوبی از نوع داده برای مقادیر و توابع داشته‌ایم، اما در صورت نیاز به ساختار داده‌های پیچیده‌تر، چه باید کرد؟